#!/usr/bin/env ruby
require 'rubygems'

require 'pathname'
begin
  gem_home = Pathname.new(ENV["GEM_HOME"]).realpath.to_s
  current_dir = File.dirname(Pathname.new(__FILE__).realpath.to_s)
  if current_dir.index(gem_home) != 0 && File.exists?(current_dir + '/../lib/jsus.rb')
    # If we are outside gem home,
    # override whatever they got there
    # with local version of jsus
    $:.unshift File.expand_path(current_dir + "/../lib")
  end
rescue Exception => e
  # Something weird happened during our checks,
  # but it's probably nothing.
end
require 'jsus'

require "fileutils"
require "optparse"


options = {}
cli = OptionParser.new do |opts|
  opts.banner = "jsus #{Jsus.version}. Usage: jsus [options] <input_dir> <output_dir>"

  opts.on('-i', '--input-directory [DIR]', '[DEPRECATED] path to input directory ') do |dir|
    $stderr.puts "DEPRECATION NOTICE: please do not use -i command-line argument"
    options[:input_dir] = dir
  end

  opts.on('-o', '--output-directory [DIR]', '[DEPRECATED] path to output directory ') do |dir|
    $stderr.puts "DEPRECATION NOTICE: please do not use -o command-line argument"
    options[:output_dir] = dir
  end

  opts.on('-d', '--with-dependencies [DEPS]', 'path to directory containing dependency packages')  do |dir|
    options[:deps_dir] = dir
  end

  opts.on('-g', '--generate-includes [ROOT]', 'generates includes.js file that you may use for ad-hoc requiring of dependencies, defaults to output directory') do |dir|
    options[:generate_includes] = true
    options[:includes_root] = dir
  end

  opts.on('--generate-docs [*CLASSES]', Array, "generate docs for some of the sources. When given empty array, defaults to /**/*") do |docs|
    if !docs
      options[:documented_classes] = ["/**/*"]
    else
      options[:documented_classes] = docs
    end
  end

  opts.on('--no-syntax-highlight', 'if you turned on docs generation, it will use syntax highlighting by default. This option prevents it') do
    options[:no_syntax_highlight] = true
  end

  opts.on('--validate-with [*VALIDATORS]', Array, 'performs a check against some of the validators. Available validators: mooforge') do |validators|
    options[:validators] = (validators || []).map {|v| v.downcase }
  end

  opts.on('--postproc [*PROCESSORS]', Array, 'performs postprocessing. Available postprocs:\n* moocompat12 -- removes mootools 1.2compat tags and their contents\n* mooltIE8 -- removes mootools ltIE8 compat tags and their contents') do |postprocs|
    options[:postproc] = postprocs
  end

  opts.on('--compress', 'compresses resulting file with YUI compressor') do
    options[:compress] = true
  end

  opts.on_tail('-v', '--verbose', 'verbose mode, shows various debug messages') do
    Jsus.verbose = true
  end

  opts.on_tail('-b', '--benchmark', 'shows time spent on various stages') do
    options[:benchmark] = true
  end

  opts.on_tail('--without-scripts-info', 'do not generate scripts.json') do
    options[:without_scripts_info] = true
  end

  opts.on_tail('--without-tree-info', 'do not generate tree.json') do
    options[:without_tree_info] = true
  end

  opts.on_tail('--watch', 'watch file system events for *.js files in subdirectories and rerun jsus with the same parameters') do
    options[:watch] = true
  end

  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end
end
cli.parse!

options[:input_dir]  ||= ARGV[0]
options[:output_dir] ||= ARGV[1]

if !(options[:input_dir] && options[:output_dir])
  puts cli
  exit
end

# TODO: split into multiple methods, cleanup
launch_jsus = lambda do
  start_time = Time.now
  compile_start_time = Time.now

  pool_load_start_time = Time.now
  pool = if options[:deps_dir]
    Jsus::Pool.new(options[:deps_dir])
  else
    Jsus::Pool.new
  end
  pool_load_finish_time = Time.now

  package = Jsus::Package.new(options[:input_dir], :pool => pool)
  package.include_dependencies!
  output_dir = options[:output_dir]

  package_content = package.compile(nil)

  if options[:postproc]
    options[:postproc].each do |processor|
      case processor.strip
      when /^moocompat12$/i
        package_content.gsub!(/\/\/<1.2compat>.*?\/\/<\/1.2compat>/m, '')
        package_content.gsub!(/\/\*<1.2compat>\*\/.*?\/\*<\/1.2compat>\*\//m, '')
      when /^mooltie8$/i
        package_content.gsub!(/\/\/<ltIE8>.*?\/\/<\/ltIE8>/m, '')
        package_content.gsub!(/\/\*<ltIE8>\*\/.*?\/\*<\/ltIE8>\*\//m, '')
      else
        $stderr.puts "Unknown post-processor: #{processor}"
      end
    end
  end
  FileUtils.mkdir_p(output_dir)
  package_filename = File.join(output_dir, package.filename)
  if options[:compress]
    begin
      require 'yui/compressor'
      compressor = YUI::JavaScriptCompressor.new(:munge => true)
      compressed_content = compressor.compress(package_content)
      if compressed_content != ""
        compression_ratio = compressed_content.size.to_f / package_content.size.to_f
        package_content = compressed_content
      else
        compression_ratio = 1.00
        puts "ERROR: YUI compressor could not parse input. Falling back to uncompressed version"
        puts "Compressor command used: #{compressor.command.join(' ')}"
      end
      puts "Compression ratio: #{sprintf("%.2f%%", compression_ratio * 100)}" if Jsus.verbose?
    rescue LoadError
      puts 'ERROR: You need "yui-compressor" gem in order to use --compress option'
    end
  end
  File.open(package_filename, 'w') {|f| f << package_content  }

  package.generate_scripts_info(output_dir) unless options[:without_scripts_info]
  package.generate_tree(output_dir) unless options[:without_tree_info]

  # Validations
  validators_map = {"mooforge" => Jsus::Util::Validator::Mooforge}
  (options[:validators] || []).each do |validator_name|
    if validator = validators_map[validator_name]
      errors = validator.new(pool.sources.to_a & package.source_files.to_a).validation_errors
      unless errors.empty?
        puts "Validator #{validator_name} found errors: "
        errors.each {|e| puts "  * #{e}"}
      end
    else
      puts "No such validator: #{validator_name}"
    end
  end

  # Postprocs, sort of hack

  # Hack, hack, hack >:E
  if options[:generate_includes]
    includes_root = options[:includes_root] || output_dir
    File.open(File.join(output_dir, "includes.js"), "w") do |f|
      c = Jsus::Container.new(*(package.source_files.to_a + package.linked_external_dependencies.to_a))
      script = %{
      (function(prefix, loader) {
        var sources = %sources%;
        if (!loader) loader = function(path) {
          document.write('<scr' + 'ipt src="' + (prefix || '') + path + '"></script>');
        }
        for (var i = 0, j = sources.length; i < j; i++) loader(sources[i]);
      })(window.prefix, window.loader);}.sub("%sources%", JSON.pretty_generate(c.required_files(includes_root)))
      f.puts script
    end
  end

  docs_start_time = Time.now
  # Generate documentation
  if options[:documented_classes] && !options[:documented_classes].empty?
    documenter = Jsus::Util::Documenter.new(:highlight_source => !options[:no_syntax_highlight])
    package.source_files.each {|source| documenter << source }
    pool.sources.each {|source| documenter << source } if pool
    documenter.only(options[:documented_classes]).generate(output_dir + "/docs")
  end
  docs_finish_time = Time.now

  finish_time = Time.now


  if options[:benchmark]
    puts "Benchmarking results:"
    puts "Total execution time:   #{format("%.3f" ,finish_time - start_time)}s"
    puts ""
    puts "Of them:"
    puts "Pool preloading time:   #{format("%.3f", pool_load_finish_time - pool_load_start_time)}s"
    puts "Docs generation time:   #{format("%.3f", docs_finish_time - docs_start_time)}s" if options[:documented_classes]
    puts "Total compilation time: #{format("%.3f", finish_time - compile_start_time - (pool_load_finish_time - pool_load_start_time))}s"
  end
end

if options[:watch]
  begin
    require 'watchr'
    puts "Jsus enters watch mode, it will watch your files for changes and relaunch itself"
    puts ""
    Watchr.options.debug = Jsus.verbose?
    script = Watchr::Script.new
    watched_dirs = Regexp.escape(options[:input_dir])
    start_directory = Dir.pwd
    watched_dirs += "|#{Regexp.escape(options[:deps_dir])}" if options[:deps_dir]

    script.watch("(#{watched_dirs})\/((.*)\.js|package.yml|package.json)") do |match|
      puts "#{match} has changed, relaunching jsus..."
      launch_jsus.call
      puts "... done"
      puts ""
    end

    contrl = Watchr::Controller.new(script, Watchr.handler.new)
    contrl.run
  rescue LoadError => e
    puts "You need to install watchr gem for --watch option."
    puts "You may also want to install ruby-fsevent for OS X"
    raise e
  end
else
  launch_jsus.call
end