#!/usr/bin/env ruby
require 'rubygems'
require 'jsus'
require "fileutils"
require "murdoc"
require 'choice'
start_time = Time.now

Choice.options do
  option 'input_directory', :required => true do
    short "-i"
    long "--input-directory=DIRECTORY"
    desc "Path to directory containing your package to compile."
  end

  option 'output_directory', :required => true do
    short "-o"
    long "--output-directory=DIRECTORY"
    desc "Path to directory to output the compiled package."
  end
  
  option "dependencies", :required => false do
    short "-d"
    long  "--with-dependencies=DIRECTORY"
    desc "Path to directory containing packages this package relies on. " <<
         "If set, all the packages will be compiled into a single file."
  end

  option "without_scripts_info", :required => false do
    long "--without-scripts-info"
    desc "When this flag is set, jsus doesn't generate scripts.json" <<
         "file with general info about your package."
  end

  option "without_tree", :required => false do
    long "--without-tree"
    desc "When this flag is set, jsus doesn't generate tree.json file" <<
         "with tree structure of your package."
  end

  option "generate_includes", :required => false do
    short "-g"
    long  "--generate-includes=[ROOT]"
    desc  "Generates includes.js file that you may use for ad-hoc requiring" <<
          "of the needed javascripts. Defaults to output_directory."
  end

  option "benchmark", :required => false do
    long "--benchmark"
    short "-b"
    desc "Performs a benchmark, indicating how much time you needed to" <<
         "compile the package"
  end

  option "docs_classes", :required => false do
    default []
    long "--generate-docs *CLASSES"
    desc "Generate documentation for classes via murdoc, e.g.: lsd-* mootools-*"

  end

end

compile_start_time = Time.now

pool_load_start_time = Time.now
pool = if Choice.choices[:dependencies]
  Jsus::Pool.new(Choice.choices[:dependencies])
end
pool_load_finish_time = Time.now

package = Jsus::Package.new(Choice.choices[:input_directory], :pool => pool)
package.include_dependencies! if Choice.choices[:dependencies]
output_directory = Choice.choices[:output_directory]
package.compile(output_directory)
package.generate_scripts_info(output_directory) unless Choice.choices[:without_scripts_info]
package.generate_tree(output_directory) unless Choice.choices[:without_tree]


# Hack, hack, hack :[
if Choice.choices[:generate_includes]
  root = Choice.choices[:generate_includes] == true ? Choice.choices[:output_directory] : Choice.choices[:generate_includes]
  File.open(File.join(Choice.choices[:output_directory], "includes.js"), "w") do |f|
    c = Jsus::Container.new(*(package.source_files.to_a + package.linked_external_dependencies.to_a))
    script = %{(function(prefix) {
      var sources = %sources%;
      for (var i = 0, j = sources.length; i < j; i++) document.write('<scr' + 'ipt src="' + (prefix || '') + sources[i] + '"></script>');
    })(window.prefix);}.sub("%sources%", JSON.pretty_generate(c.required_files(root)))
    f.puts script
  end
end

# Generate documentation
unless Choice.choices[:docs_classes].empty?
  documented_sources = Jsus::Container.new
  sources = pool ? pool.sources : package.source_files
  Choice.choices[:docs_classes].each do |expr|
    regex = Regexp.new("^" + expr.gsub("*", ".*") + "$", Regexp::IGNORECASE)
    sources.each {|s| documented_sources << s if s.provides.any? {|provided| provided.to_s =~ regex } }
  end

  doc_dir = Choice.choices[:output_directory] + "/docs"
  FileUtils.mkdir_p(doc_dir)
  template = File.dirname(__FILE__) + "/../markup/template.haml"
  sources_index = {}
  documented_sources.each do |source|
    content = source.original_content.gsub(/\A\s*\/\*.*?\*\//m, "") # deleting initial comment
    annotator = Murdoc::Annotator.new(content, :javascript, :highlight_source => true)
    header = source.header
    sources_index[source.package.name] ||= []
    source_dir = "#{doc_dir}/#{source.package.name}"
    FileUtils.mkdir_p(source_dir)
    File.open("#{source_dir}/#{File.basename(source.filename)}.html", "w+") do |f|
      sources_index[source.package.name] << File.basename(source.filename)
      f.puts Murdoc::Formatter.new(template).render(:paragraphs => annotator.paragraphs, :header => header, :source => source)
    end
  end

  FileUtils.cp(File.dirname(__FILE__) + "/../markup/stylesheet.css", doc_dir)

  # building indices
  sources_index.each do |pkg, sources_names|
    source_dir = "#{doc_dir}/#{pkg}"
    FileUtils.cp("#{doc_dir}/stylesheet.css", source_dir)
    File.open("#{source_dir}/index.html", "w+") do |f|
      f.puts Haml::Engine.new(File.read(File.dirname(__FILE__) + "/../markup/index.haml")).render(self, :package => pkg, :sources => sources_names)
    end
  end

  # building main index of packages
  File.open("#{doc_dir}/index.html", "w+") do |f|
    f.puts Haml::Engine.new(File.read(File.dirname(__FILE__) + "/../markup/packages_index.haml")).render(self, :packages => sources_index.keys)
  end
end


finish_time = Time.now


if Choice.choices[:benchmark]
  puts "Benchmarking results:"
  puts "Total execution time:   #{format("%.3f" ,finish_time - start_time)}s"
  puts ""
  puts "Of them:"
  puts "Pool preloading time:   #{format("%.3f", pool_load_finish_time - pool_load_start_time)}s"
  puts "Total compilation time: #{format("%.3f", finish_time - compile_start_time - (pool_load_finish_time - pool_load_start_time))}s"
end
