#!/usr/bin/env ruby
require 'rubygems'
begin
  require 'jsus'
rescue LoadError
  $: << "./lib"
  require "jsus"
end

require "fileutils"
require 'choice'
start_time = Time.now

Choice.options do
  option 'input_directory', :required => true do
    short "-i"
    long "--input-directory=DIRECTORY"
    desc "Path to directory containing your package to compile."
  end

  option 'output_directory', :required => true do
    short "-o"
    long "--output-directory=DIRECTORY"
    desc "Path to directory to output the compiled package."
  end
  
  option "dependencies", :required => false do
    short "-d"
    long  "--with-dependencies=DIRECTORY"
    desc "Path to directory containing packages this package relies on. " <<
         "If set, all the packages will be compiled into a single file."
  end

  option "without_scripts_info", :required => false do
    long "--without-scripts-info"
    desc "When this flag is set, jsus doesn't generate scripts.json" <<
         "file with general info about your package."
  end

  option "without_tree", :required => false do
    long "--without-tree"
    desc "When this flag is set, jsus doesn't generate tree.json file" <<
         "with tree structure of your package."
  end

  option "generate_includes", :required => false do
    short "-g"
    long  "--generate-includes=[ROOT]"
    desc  "Generates includes.js file that you may use for ad-hoc requiring" <<
          "of the needed javascripts. Defaults to output_directory."
  end

  option "benchmark", :required => false do
    long "--benchmark"
    short "-b"
    desc "Performs a benchmark, indicating how much time you needed to" <<
         "compile the package"
  end

  option "docs_classes", :required => false do
    default []
    long "--generate-docs *CLASSES"
    desc "Generate documentation for classes via murdoc. You need to use FULL PATHS, e.g.: " <<
         "/mootools/*, /LSD/*, /**/*"

  end

  option "verbose", :required => false do
    default false
    short "-v"
    long "--verbose"
    desc "When verbose mode is enabled, some debug information is displayed. Defaults to false."
  end

end

compile_start_time = Time.now

Jsus.verbose = Choice.choices[:verbose]

pool_load_start_time = Time.now
pool = if Choice.choices[:dependencies]
  Jsus::Pool.new(Choice.choices[:dependencies])
end
pool_load_finish_time = Time.now

package = Jsus::Package.new(Choice.choices[:input_directory], :pool => pool)
package.include_dependencies! if Choice.choices[:dependencies]
output_directory = Choice.choices[:output_directory]
package.compile(output_directory)
package.generate_scripts_info(output_directory) unless Choice.choices[:without_scripts_info]
package.generate_tree(output_directory) unless Choice.choices[:without_tree]


# Hack, hack, hack :[
if Choice.choices[:generate_includes]
  root = Choice.choices[:generate_includes] == true ? Choice.choices[:output_directory] : Choice.choices[:generate_includes]
  File.open(File.join(Choice.choices[:output_directory], "includes.js"), "w") do |f|
    c = Jsus::Container.new(*(package.source_files.to_a + package.linked_external_dependencies.to_a))
    script = %{(function(prefix) {
      var sources = %sources%;
      for (var i = 0, j = sources.length; i < j; i++) document.write('<scr' + 'ipt src="' + (prefix || '') + sources[i] + '"></script>');
    })(window.prefix);}.sub("%sources%", JSON.pretty_generate(c.required_files(root)))
    f.puts script
  end
end

# Generate documentation
unless Choice.choices[:docs_classes].empty?  
  documenter = Jsus::Documenter.new
  package.source_files.each {|source| documenter << source }
  pool.sources.each {|source| documenter << source } if pool
  documenter.only(Choice.choices[:docs_classes]).generate(Choice.choices[:output_directory] + "/docs")
end


finish_time = Time.now


if Choice.choices[:benchmark]
  puts "Benchmarking results:"
  puts "Total execution time:   #{format("%.3f" ,finish_time - start_time)}s"
  puts ""
  puts "Of them:"
  puts "Pool preloading time:   #{format("%.3f", pool_load_finish_time - pool_load_start_time)}s"
  puts "Total compilation time: #{format("%.3f", finish_time - compile_start_time - (pool_load_finish_time - pool_load_start_time))}s"
end
